<!DOCTYPE html><html lang="en"><head><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="icon" type="image/png" href="/favicons/woman-technologist.png"/><link rel="manifest" href="/favicons/site.webmanifest"/><link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#000000"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/styles/default.min.css"/><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js"></script><script>hljs.highlightAll();</script><link rel="shortcut icon" href="/favicons/woman-technologist.png"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="Patience Shyu, Senior Software Engineer"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><script data-goatcounter="https://patiences.goatcounter.com/count" async="" src="//gc.zgo.at/count.js"></script><title>Static Analysis and Abstract Interpretation</title><meta name="next-head-count" content="18"/><link rel="preload" href="/_next/static/css/e6dea86d5ceaa009.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e6dea86d5ceaa009.css" data-n-g=""/><link rel="preload" href="/_next/static/css/e1f6961df2961232.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e1f6961df2961232.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-eab312c0bf2a7270.js" defer=""></script><script src="/_next/static/chunks/pages/_app-90e414d931afb8eb.js" defer=""></script><script src="/_next/static/chunks/621-61fd141301762a3d.js" defer=""></script><script src="/_next/static/chunks/672-76c886ad533112eb.js" defer=""></script><script src="/_next/static/chunks/pages/writing/%5Bslug%5D-13abfa1974d18446.js" defer=""></script><script src="/_next/static/VF5E5_MiSoGPufd4Fs3Ym/_buildManifest.js" defer=""></script><script src="/_next/static/VF5E5_MiSoGPufd4Fs3Ym/_ssgManifest.js" defer=""></script><script src="/_next/static/VF5E5_MiSoGPufd4Fs3Ym/_middlewareManifest.js" defer=""></script><style data-href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@100;400&display=swap">@font-face{font-family:'IBM Plex Mono';font-style:normal;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/ibmplexmono/v19/-F6pfjptAgt5VM-kVkqdyU8n3kwq0Q.woff) format('woff')}@font-face{font-family:'IBM Plex Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ibmplexmono/v19/-F63fjptAgt5VM-kVkqdyU8n5is.woff) format('woff')}@font-face{font-family:'IBM Plex Mono';font-style:normal;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/ibmplexmono/v19/-F6pfjptAgt5VM-kVkqdyU8n3kwa2HdgregdFOFh.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C8A,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'IBM Plex Mono';font-style:normal;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/ibmplexmono/v19/-F6pfjptAgt5VM-kVkqdyU8n3kwa0XdgregdFOFh.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'IBM Plex Mono';font-style:normal;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/ibmplexmono/v19/-F6pfjptAgt5VM-kVkqdyU8n3kwa2ndgregdFOFh.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'IBM Plex Mono';font-style:normal;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/ibmplexmono/v19/-F6pfjptAgt5VM-kVkqdyU8n3kwa23dgregdFOFh.woff2) format('woff2');unicode-range:U+0100-02BA,U+02BD-02C5,U+02C7-02CC,U+02CE-02D7,U+02DD-02FF,U+0304,U+0308,U+0329,U+1D00-1DBF,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'IBM Plex Mono';font-style:normal;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/ibmplexmono/v19/-F6pfjptAgt5VM-kVkqdyU8n3kwa1XdgregdFA.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'IBM Plex Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ibmplexmono/v19/-F63fjptAgt5VM-kVkqdyU8n1iIq131nj-otFQ.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C8A,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'IBM Plex Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ibmplexmono/v19/-F63fjptAgt5VM-kVkqdyU8n1isq131nj-otFQ.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'IBM Plex Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ibmplexmono/v19/-F63fjptAgt5VM-kVkqdyU8n1iAq131nj-otFQ.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'IBM Plex Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ibmplexmono/v19/-F63fjptAgt5VM-kVkqdyU8n1iEq131nj-otFQ.woff2) format('woff2');unicode-range:U+0100-02BA,U+02BD-02C5,U+02C7-02CC,U+02CE-02D7,U+02DD-02FF,U+0304,U+0308,U+0329,U+1D00-1DBF,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'IBM Plex Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ibmplexmono/v19/-F63fjptAgt5VM-kVkqdyU8n1i8q131nj-o.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next" data-reactroot=""><div class="intro"><main><div class="container mx-auto w-11/12 sm:w-5/6 intro-card jumbotron"><section class="flex-col md:flex-row items-center"><h1 class="text-7xl md:text-8xl tracking-tighter leading-tight hello">hi, i&#x27;m patience!</h1><div class="links md:text-3xl flex flex-wrap"><a class="pr-8" href="/">home</a><a class="pr-8 active" href="/writing">writing</a><a class="pr-8" href="http://github.com/patiences">github</a><a class="pr-8" href="http://linkedin.com/in/patienceshyu">linkedin</a><a class="pr-8" href="mailto:patienceshyu@gmail.com">email</a></div></section><article class="mb-32"><div class="mb-4 text-lg text-slate-700 post-content"><time dateTime="2017-06-01T00:00:00.322Z">June	1, 2017</time></div><h1 class="post-title text-4xl sm:text-4xl md:text-6xl lg:text-7xl tracking-tighter leading-tight md:leading-none mb-6 text-center md:text-left">Static Analysis and Abstract Interpretation</h1><div class="mb-12"><p class="py-2 px-4 text-xs sm:text-base inline-block rounded-full font-extrabold bg-[#FE6A6A]/75 mr-2 mb-2 text-white post-content">programming languages</p><p class="py-2 px-4 text-xs sm:text-base inline-block rounded-full font-extrabold bg-[#FE6A6A]/75 mr-2 mb-2 text-white post-content">program analysis</p><p class="py-2 px-4 text-xs sm:text-base inline-block rounded-full font-extrabold bg-[#FE6A6A]/75 mr-2 mb-2 text-white post-content">abstract interpretation</p></div><div class=" mx-auto post-content"><div class="markdown-styles_markdown__h_8de"><p>This is the second of three posts written about what I learned at the <a href="https://pliss2017.github.io/">Programming Language Implementation Summer School</a>.</p>
<p>Abstract interpretation has a reputation for being inaccessible. So I was very excited about two of the talks which promised gentle introductions to abstract interpretation, from <a href="https://www.linkedin.com/in/francesco-logozzo-4106386/">Francesco Logozzo</a> at Facebook and <a href="http://matt.might.net/">Matt Might</a> at the University of Utah (one of his last CS lectures too, before he takes officially the plunge into medicine!)</p>
<h2>The engineering motivation</h2>
<p>As programmers, we'd like to be able to write efficient code with as few bugs as possible. Unfortunately, the software engineering workflow doesn't really help us do this easily.</p>
<p><img src="/assets/blog/static-analysis-and-abstract-interpretation/se-cartoon.jpg" alt="Matt&#x27;s Slide" title="Matt&#x27;s slide"></p>
<p>We try to write thorough tests, but the test suite grows with each bug fix. We rely on engineers with more experience to tell us about optimizations during code review, but if you don't have people with that kind of expertise on your team, then you're out of luck.</p>
<p>That's why programming languages researchers have been working on static analysis techniques for forever, because static analysis can help catch bugs and find places ripe for optimization.</p>
<h2>So what is static analysis?</h2>
<p>Static analysis is about gathering information about a program without executing it.</p>
<h2>And what is abstract interpretation?</h2>
<p>Abstract interpretation is an approximation over all possible executions of a program.</p>
<p>That sounds cryptic, but Francesco showed us an informal way to visualize it, and seeing the pictures really helped me. Let me try to replicate it:</p>
<p>We want to find some way to express all the possible things that can happen during the program execution. So if we try to imagine what all possible executions of a program might look like, we could end up with something like this:</p>
<p><img src="/assets/blog/static-analysis-and-abstract-interpretation/ai-trajectories.jpg" alt="AI Trajectories" title="AI Trajectories"></p>
<p>Disclaimer: This graph is from Patrick Cousot's <a href="http://www.di.ens.fr/~cousot/AI/IntroAbsInt.html">Abstract Interpretation in a Nutshell</a>. The green and red coloring on subsequent images is my doing :-)</p>
<p>Each colored line is a single execution, and the lot comprise the set of all possible executions (called the concrete semantics).</p>
<p>Now if I color the execution space with this green color, then we can think of the entire green space as an abstraction of all the executions that lie within it (the abstract semantics).</p>
<p><img src="/assets/blog/static-analysis-and-abstract-interpretation/ai-highlighted.jpg" alt="AI Highlighted" title="AI Highlighted"></p>
<p>We can add red areas to indicate something like an error zone:</p>
<p><img src="/assets/blog/static-analysis-and-abstract-interpretation/ai-red.jpg" alt="AI Red" title="AI Red"></p>
<p>And now the cool part is that if we can say something about the green zone, then it applies to the program as well since all executions are bounded by the green. For example, if we can prove that the green zone never overlaps with the red zone, then we know that the program cannot produce those errors.</p>
<h2>How do we use this?</h2>
<p>We can actually perform abstract interpretation of a program via static analysis. That is, we can build a <em>partial</em> interpreter, and since it's not a real interpreter, when we use that on a program we're performing a static analysis. Matt showed us how to easily turn an interpreter into an abstract interpreter, which I will briefly outline here (but he has a whole <a href="http://matt.might.net/articles/intro-static-analysis/">blog post</a> on this which is very good and easy to follow).</p>
<p>Consider a simple case of sign analysis: we want to know whether the result of an arithmetic expression is positive, negative, or zero.</p>
<p><img src="/assets/blog/static-analysis-and-abstract-interpretation/expr-rkt.jpg" alt="Expr Racket" title="Expr Racket"></p>
<p>Now the code for determining the value of the expression might look something like this:</p>
<p><img src="/assets/blog/static-analysis-and-abstract-interpretation/eval-rkt.jpg" alt="Eval Racket" title="Eval Racket"></p>
<p>Warning: this is pseudocode.</p>
<p>But if we just want to know the sign, we can tweak it a little bit by:</p>
<ol>
<li>Changing <em>eval</em> to <em>eval-sign</em></li></li>
<li>Adding 3 helper functions <em>abstract</em>, <em>+/abstract</em> and *<em>/abstract</em> (omitted here for brevity)</li></li>
<li>Wrapping the results inside <em>eval-sign</em> with our abstract helper functions</li></li>
</ol>
<p><img src="/assets/blog/static-analysis-and-abstract-interpretation/abstract-rkt.jpg" alt="Abstract Racket" title="Abstract Racket"></p>
<p>Disclaimer: this is Matt's code (I have made some simplications), as detailed on his blog.</p>
<p>Notice that we have lost some information going from the original value <em>42</em> to <em>positive</em>. In other cases, we can get all of <em>negative</em>, <em>positive</em> and <em>zero</em> (sign is unknown).</p>
<p>But we didn't have to <em>run</em> the program! In this toy example there really isn't a time savings because we execute even more lines of code, but it really isn't about creating a cheaper and less precise interpreter -- the information we get from the abstraction can help us make decisions about potential optimizations (maybe a value can never be negative, so we don't need to handle negative values), or catch bugs (perhaps we made an incorrect assumption that a value can't be zero).</p>
<h2>Lingering questions</h2>
<p>So, abstract interpretation is pretty awesome. As far as I can tell, the community is still actively working on abstract interpretation and static analysis techniques. However, I wonder if there are a few issues that make the most powerful static analyses not so usable:</p>
<ol>
<li>Do existing static analysis tools fit into the development process? One barrier to use is that good tool design, which includes meaningful explanations of defects, automatic fixes, and easy configurability is hard.</li>
<li>Do you always have to know what information you want to abstract from the program? What if you don't know the "shape" of the concrete semantics and can't figure out what kind of analysis you want to do? Are there all-purpose static analyses?</li>
<li>Isn't it expensive? Francesco mentioned that they could run a static analyzer on the entire Facebook codebase (tens of millions of LOC) in about 19 minutes. I would love to see more performance stats.</li>
</ol>
<p>References:</p>
<p>B. Johnson, Y. Song and E. Murphy-Hill. "Why Don't Software Developers Use Static Analysis Tools to Find Bugs?" in <em>Proc. ICSE</em>, 2013, pp.672-681</p>
</div></div></article></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Static Analysis and Abstract Interpretation","date":"2017-06-01T00:00:00.322Z","tags":["programming languages","program analysis","abstract interpretation"],"slug":"static-analysis-and-abstract-interpretation","content":"\u003cp\u003eThis is the second of three posts written about what I learned at the \u003ca href=\"https://pliss2017.github.io/\"\u003eProgramming Language Implementation Summer School\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eAbstract interpretation has a reputation for being inaccessible. So I was very excited about two of the talks which promised gentle introductions to abstract interpretation, from \u003ca href=\"https://www.linkedin.com/in/francesco-logozzo-4106386/\"\u003eFrancesco Logozzo\u003c/a\u003e at Facebook and \u003ca href=\"http://matt.might.net/\"\u003eMatt Might\u003c/a\u003e at the University of Utah (one of his last CS lectures too, before he takes officially the plunge into medicine!)\u003c/p\u003e\n\u003ch2\u003eThe engineering motivation\u003c/h2\u003e\n\u003cp\u003eAs programmers, we'd like to be able to write efficient code with as few bugs as possible. Unfortunately, the software engineering workflow doesn't really help us do this easily.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/blog/static-analysis-and-abstract-interpretation/se-cartoon.jpg\" alt=\"Matt\u0026#x27;s Slide\" title=\"Matt\u0026#x27;s slide\"\u003e\u003c/p\u003e\n\u003cp\u003eWe try to write thorough tests, but the test suite grows with each bug fix. We rely on engineers with more experience to tell us about optimizations during code review, but if you don't have people with that kind of expertise on your team, then you're out of luck.\u003c/p\u003e\n\u003cp\u003eThat's why programming languages researchers have been working on static analysis techniques for forever, because static analysis can help catch bugs and find places ripe for optimization.\u003c/p\u003e\n\u003ch2\u003eSo what is static analysis?\u003c/h2\u003e\n\u003cp\u003eStatic analysis is about gathering information about a program without executing it.\u003c/p\u003e\n\u003ch2\u003eAnd what is abstract interpretation?\u003c/h2\u003e\n\u003cp\u003eAbstract interpretation is an approximation over all possible executions of a program.\u003c/p\u003e\n\u003cp\u003eThat sounds cryptic, but Francesco showed us an informal way to visualize it, and seeing the pictures really helped me. Let me try to replicate it:\u003c/p\u003e\n\u003cp\u003eWe want to find some way to express all the possible things that can happen during the program execution. So if we try to imagine what all possible executions of a program might look like, we could end up with something like this:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/blog/static-analysis-and-abstract-interpretation/ai-trajectories.jpg\" alt=\"AI Trajectories\" title=\"AI Trajectories\"\u003e\u003c/p\u003e\n\u003cp\u003eDisclaimer: This graph is from Patrick Cousot's \u003ca href=\"http://www.di.ens.fr/~cousot/AI/IntroAbsInt.html\"\u003eAbstract Interpretation in a Nutshell\u003c/a\u003e. The green and red coloring on subsequent images is my doing :-)\u003c/p\u003e\n\u003cp\u003eEach colored line is a single execution, and the lot comprise the set of all possible executions (called the concrete semantics).\u003c/p\u003e\n\u003cp\u003eNow if I color the execution space with this green color, then we can think of the entire green space as an abstraction of all the executions that lie within it (the abstract semantics).\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/blog/static-analysis-and-abstract-interpretation/ai-highlighted.jpg\" alt=\"AI Highlighted\" title=\"AI Highlighted\"\u003e\u003c/p\u003e\n\u003cp\u003eWe can add red areas to indicate something like an error zone:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/blog/static-analysis-and-abstract-interpretation/ai-red.jpg\" alt=\"AI Red\" title=\"AI Red\"\u003e\u003c/p\u003e\n\u003cp\u003eAnd now the cool part is that if we can say something about the green zone, then it applies to the program as well since all executions are bounded by the green. For example, if we can prove that the green zone never overlaps with the red zone, then we know that the program cannot produce those errors.\u003c/p\u003e\n\u003ch2\u003eHow do we use this?\u003c/h2\u003e\n\u003cp\u003eWe can actually perform abstract interpretation of a program via static analysis. That is, we can build a \u003cem\u003epartial\u003c/em\u003e interpreter, and since it's not a real interpreter, when we use that on a program we're performing a static analysis. Matt showed us how to easily turn an interpreter into an abstract interpreter, which I will briefly outline here (but he has a whole \u003ca href=\"http://matt.might.net/articles/intro-static-analysis/\"\u003eblog post\u003c/a\u003e on this which is very good and easy to follow).\u003c/p\u003e\n\u003cp\u003eConsider a simple case of sign analysis: we want to know whether the result of an arithmetic expression is positive, negative, or zero.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/blog/static-analysis-and-abstract-interpretation/expr-rkt.jpg\" alt=\"Expr Racket\" title=\"Expr Racket\"\u003e\u003c/p\u003e\n\u003cp\u003eNow the code for determining the value of the expression might look something like this:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/blog/static-analysis-and-abstract-interpretation/eval-rkt.jpg\" alt=\"Eval Racket\" title=\"Eval Racket\"\u003e\u003c/p\u003e\n\u003cp\u003eWarning: this is pseudocode.\u003c/p\u003e\n\u003cp\u003eBut if we just want to know the sign, we can tweak it a little bit by:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eChanging \u003cem\u003eeval\u003c/em\u003e to \u003cem\u003eeval-sign\u003c/em\u003e\u003c/li\u003e\u003c/li\u003e\n\u003cli\u003eAdding 3 helper functions \u003cem\u003eabstract\u003c/em\u003e, \u003cem\u003e+/abstract\u003c/em\u003e and *\u003cem\u003e/abstract\u003c/em\u003e (omitted here for brevity)\u003c/li\u003e\u003c/li\u003e\n\u003cli\u003eWrapping the results inside \u003cem\u003eeval-sign\u003c/em\u003e with our abstract helper functions\u003c/li\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"/assets/blog/static-analysis-and-abstract-interpretation/abstract-rkt.jpg\" alt=\"Abstract Racket\" title=\"Abstract Racket\"\u003e\u003c/p\u003e\n\u003cp\u003eDisclaimer: this is Matt's code (I have made some simplications), as detailed on his blog.\u003c/p\u003e\n\u003cp\u003eNotice that we have lost some information going from the original value \u003cem\u003e42\u003c/em\u003e to \u003cem\u003epositive\u003c/em\u003e. In other cases, we can get all of \u003cem\u003enegative\u003c/em\u003e, \u003cem\u003epositive\u003c/em\u003e and \u003cem\u003ezero\u003c/em\u003e (sign is unknown).\u003c/p\u003e\n\u003cp\u003eBut we didn't have to \u003cem\u003erun\u003c/em\u003e the program! In this toy example there really isn't a time savings because we execute even more lines of code, but it really isn't about creating a cheaper and less precise interpreter -- the information we get from the abstraction can help us make decisions about potential optimizations (maybe a value can never be negative, so we don't need to handle negative values), or catch bugs (perhaps we made an incorrect assumption that a value can't be zero).\u003c/p\u003e\n\u003ch2\u003eLingering questions\u003c/h2\u003e\n\u003cp\u003eSo, abstract interpretation is pretty awesome. As far as I can tell, the community is still actively working on abstract interpretation and static analysis techniques. However, I wonder if there are a few issues that make the most powerful static analyses not so usable:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eDo existing static analysis tools fit into the development process? One barrier to use is that good tool design, which includes meaningful explanations of defects, automatic fixes, and easy configurability is hard.\u003c/li\u003e\n\u003cli\u003eDo you always have to know what information you want to abstract from the program? What if you don't know the \"shape\" of the concrete semantics and can't figure out what kind of analysis you want to do? Are there all-purpose static analyses?\u003c/li\u003e\n\u003cli\u003eIsn't it expensive? Francesco mentioned that they could run a static analyzer on the entire Facebook codebase (tens of millions of LOC) in about 19 minutes. I would love to see more performance stats.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eReferences:\u003c/p\u003e\n\u003cp\u003eB. Johnson, Y. Song and E. Murphy-Hill. \"Why Don't Software Developers Use Static Analysis Tools to Find Bugs?\" in \u003cem\u003eProc. ICSE\u003c/em\u003e, 2013, pp.672-681\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/writing/[slug]","query":{"slug":"static-analysis-and-abstract-interpretation"},"buildId":"VF5E5_MiSoGPufd4Fs3Ym","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>