<!DOCTYPE html><html lang="en"><head><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="icon" type="image/png" href="/favicons/woman-technologist.png"/><link rel="manifest" href="/favicons/site.webmanifest"/><link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#000000"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/styles/default.min.css"/><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js"></script><script>hljs.highlightAll();</script><link rel="shortcut icon" href="/favicons/woman-technologist.png"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="Patience Shyu, Senior Software Engineer"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><script data-goatcounter="https://patiences.goatcounter.com/count" async="" src="//gc.zgo.at/count.js"></script><title>Worry-free Concurrent Programming in Pony</title><meta name="next-head-count" content="18"/><link rel="preload" href="/_next/static/css/e6dea86d5ceaa009.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e6dea86d5ceaa009.css" data-n-g=""/><link rel="preload" href="/_next/static/css/e1f6961df2961232.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e1f6961df2961232.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-eab312c0bf2a7270.js" defer=""></script><script src="/_next/static/chunks/pages/_app-90e414d931afb8eb.js" defer=""></script><script src="/_next/static/chunks/621-61fd141301762a3d.js" defer=""></script><script src="/_next/static/chunks/672-76c886ad533112eb.js" defer=""></script><script src="/_next/static/chunks/pages/writing/%5Bslug%5D-13abfa1974d18446.js" defer=""></script><script src="/_next/static/pMomVlEDc5orNd4LjOJ5J/_buildManifest.js" defer=""></script><script src="/_next/static/pMomVlEDc5orNd4LjOJ5J/_ssgManifest.js" defer=""></script><script src="/_next/static/pMomVlEDc5orNd4LjOJ5J/_middlewareManifest.js" defer=""></script><style data-href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@100;400&display=swap">@font-face{font-family:'IBM Plex Mono';font-style:normal;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/ibmplexmono/v19/-F6pfjptAgt5VM-kVkqdyU8n3kwq0Q.woff) format('woff')}@font-face{font-family:'IBM Plex Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ibmplexmono/v19/-F63fjptAgt5VM-kVkqdyU8n5is.woff) format('woff')}@font-face{font-family:'IBM Plex Mono';font-style:normal;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/ibmplexmono/v19/-F6pfjptAgt5VM-kVkqdyU8n3kwa2HdgregdFOFh.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C8A,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'IBM Plex Mono';font-style:normal;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/ibmplexmono/v19/-F6pfjptAgt5VM-kVkqdyU8n3kwa0XdgregdFOFh.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'IBM Plex Mono';font-style:normal;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/ibmplexmono/v19/-F6pfjptAgt5VM-kVkqdyU8n3kwa2ndgregdFOFh.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'IBM Plex Mono';font-style:normal;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/ibmplexmono/v19/-F6pfjptAgt5VM-kVkqdyU8n3kwa23dgregdFOFh.woff2) format('woff2');unicode-range:U+0100-02BA,U+02BD-02C5,U+02C7-02CC,U+02CE-02D7,U+02DD-02FF,U+0304,U+0308,U+0329,U+1D00-1DBF,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'IBM Plex Mono';font-style:normal;font-weight:100;font-display:swap;src:url(https://fonts.gstatic.com/s/ibmplexmono/v19/-F6pfjptAgt5VM-kVkqdyU8n3kwa1XdgregdFA.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'IBM Plex Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ibmplexmono/v19/-F63fjptAgt5VM-kVkqdyU8n1iIq131nj-otFQ.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C8A,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'IBM Plex Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ibmplexmono/v19/-F63fjptAgt5VM-kVkqdyU8n1isq131nj-otFQ.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'IBM Plex Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ibmplexmono/v19/-F63fjptAgt5VM-kVkqdyU8n1iAq131nj-otFQ.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'IBM Plex Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ibmplexmono/v19/-F63fjptAgt5VM-kVkqdyU8n1iEq131nj-otFQ.woff2) format('woff2');unicode-range:U+0100-02BA,U+02BD-02C5,U+02C7-02CC,U+02CE-02D7,U+02DD-02FF,U+0304,U+0308,U+0329,U+1D00-1DBF,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'IBM Plex Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/ibmplexmono/v19/-F63fjptAgt5VM-kVkqdyU8n1i8q131nj-o.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next" data-reactroot=""><div class="intro"><main><div class="container mx-auto w-11/12 sm:w-5/6 intro-card jumbotron"><section class="flex-col md:flex-row items-center"><h1 class="text-7xl md:text-8xl tracking-tighter leading-tight hello">hi, i&#x27;m patience!</h1><div class="links md:text-3xl flex flex-wrap"><a class="pr-8" href="/">home</a><a class="pr-8 active" href="/writing">writing</a><a class="pr-8" href="http://github.com/patiences">github</a><a class="pr-8" href="http://linkedin.com/in/patienceshyu">linkedin</a><a class="pr-8" href="mailto:patienceshyu@gmail.com">email</a></div></section><article class="mb-32"><div class="mb-4 text-lg text-slate-700 post-content"><time dateTime="2017-05-30T00:00:00.322Z">May	30, 2017</time></div><h1 class="post-title text-4xl sm:text-4xl md:text-6xl lg:text-7xl tracking-tighter leading-tight md:leading-none mb-6 text-center md:text-left">Worry-free Concurrent Programming in Pony</h1><div class="mb-12"><p class="py-2 px-4 text-xs sm:text-base inline-block rounded-full font-extrabold bg-[#FE6A6A]/75 mr-2 mb-2 text-white post-content">pony</p><p class="py-2 px-4 text-xs sm:text-base inline-block rounded-full font-extrabold bg-[#FE6A6A]/75 mr-2 mb-2 text-white post-content">programming languages</p></div><div class=" mx-auto post-content"><div class="markdown-styles_markdown__h_8de"><p>I spent the past week at the <a href="https://pliss2017.github.io/">Programming Language Implementation Summer School</a> in Bertinoro, Italy. Throughout my undergrad I've avoided taking classes in the summer but when Ron told me about this one in Italy I couldn't not apply. Now that the week is over and I'm sunning it up in Croatia, I want to write a few blog posts about some stuff I learned both in and out of the classroom. This is the first of three posts.</p>
<p><img src="/assets/blog/pony/pliss-classroom.jpeg" alt="PLISS classroom" title="PLISS classroom"></p>
<p>Writing concurrent programs is hard. At the heart of the challenge is handling shared data — and to that, our Intro to Computer Science professors say: put a lock on it! But programming with locks and semaphores is very difficult to get right and is torturously slow (imagine Facebook locking each of Donald Trump’s posts when someone comments). The <a href="https://www.ponylang.org/">Pony</a> language, being developed at <a href="https://wp.doc.ic.ac.uk/sd/">Sophia Drossopoulou</a>’s group at Imperial College London, introduces two core ideas such that, if you can get your program to compile, guarantees memory safety (among other things).</p>
<h2>The Actor Model</h2>
<p>The first of these is the actor model. This isn’t really a new idea — probably the best known language that uses this is Erlang. Instead of the traditional threads, we have actors, and they define the concurrent system. Each actor does its own computation, receives messages, and sends messages to other actors. The actor executes each message in its entirety and sequentially. So the concurrency happens when you have multiple actors, each doing their own thing.</p>
<p>To me this is a very intuitive model to think about parallel work. Suppose I want to ask a bunch of people to do my homework. I’d probably make photocopies to distribute to each of my minions, and they’ll each work on an assigned question, and send it back to me when they’re done. Notice that while they’re doing the work, each one has its own copy — there is no passing around one homework a la Sisterhood of the Traveling Pants. In the actor model, each actor always has its own private state.</p>
<h2>Reference Capabilities</h2>
<p>But this is not still not enough, because we need to define the rules around shared data. Pony’s solution to this is reference capabilities: an extra tag that you write with the type (Pony is strongly typed) for each variable that tells you how that variable can be used. There are <a href="https://tutorial.ponylang.org/capabilities/reference-capabilities.html">6 of these</a>, from <em>iso</em> and <em>val</em> (isolated, as in no other variables can access the data, and immutable, respectively) to <em>ref</em> and <em>box</em> (mutable and read-only, respectively).</p>
<p>Confused? I am. From a theoretical perspective, ref capabilities are absolutely beautiful. But for an engineer who just wanted to hit the ground running, the powerful type system was, at first, a bit off-putting. I’m used to writing programs that compile with little effort (usually because the problems are hiding somewhere where it’s hard to diagnose and hard to debug).</p>
<h2>Tada...</h2>
<p>This combination gets us some very nice (and interesting) guarantees.</p>
<ul>
<li><strong>No data races.</strong> If an actor sees some object as writeable (<em>iso</em> or <em>ref</em>) then all other actors see the object as unreadable and unwritable (<em>tag</em>).</li>
<li><strong>Immutability is deep and permanent.</strong> If an actor sees some object as immutable (<em>val</em>), its contents are also immutable.</li>
<li><strong>Atomicity.</strong> We can trace what happened when without too much difficulty. If an actor <i>a</i> at some point <i>C</i> sees an object <i>o</i> with a non-tag capability(so <i>a</i> can actually do something with <i>o</i>) without message receipts, and <i>o</i> is different at some earlier point, then <i>a</i> did it: <i>a</i> must have either created or modified <i>o</i>.</li>
<li>Lots more <a href="https://tutorial.ponylang.org/capabilities/guarantees.html">here</a>...</li>
</ul>
<h2>What about Rust? Why not Rust?</h2>
<p>Idiomatically I think Rust's and Pony's approaches to memory safety aren't so different -- capabilities can capture a bit more information than mutabilities, but essentially they are just about annotating data with restrictions. However, Pony’s core focus is safe concurrency, and with the actor model you have to think in a totally different way even when you’re writing a sequential program (though who ever did anything interesting with a sequential program?), whereas Rust is more familiar for those of us coming from the C world.</p>
<p>One advantage that Pony has over Rust is creating and manipulating cyclic data structures. Cyclic data structures are nontrivial in Rust, partly because of the mutability qualifiers (I mean check out this implementation of <a href="https://github.com/nrc/r4cppp/tree/master/graphs">graphs</a>). According to Sophia, it’s much more painless in Pony (need to try this for myself though).</p>
<h2>Borrowing?</h2>
<p>There isn’t really a concept of borrowing yet, although I think you can fake it by <a href="https://tutorial.ponylang.org/capabilities/recovering-capabilities.html">recovering capabilities</a> (essentially change the capability so the variable can be passed to and changed by another actor). It’s next on their to-do list, though!</p>
<h2>How usable is it, really?</h2>
<p>I think there’s a trend in recent years towards languages that have as flat a learning curve as possible. It seems like languages that are a bit prickly at first (because of the type system or otherwise) haven’t gained much traction. On the other hand, dynamic languages like Python and Ruby are still going strong. Rust, for example, started off with a lot more structure baked into the language and spent years simplifying and pushing abstractions into libraries (see <a href="https://doc.rust-lang.org/std/cell/">Cells</a> and <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">RefCells</a> for example) to make it more accessible. The Pony developers don't currently anticipate having to water down their type system (I asked :-) ).</p>
<p>Last week, I was definitely on the Python train… now I’m not so sure. What would it take for the masses to adopt a language like Pony?</p>
<p>Can we convince the programming community to have enough patience to handle compiler errors if it means we have fewer of those seriously painful concurrency bugs later down the line?</p>
<p>I’d personally much rather debug a compile error with a nice message than a deadlock, but first it's about getting out of the mindset that the compilation step is trivial.</p>
<br />
<p><strong>06-01-2017 EDIT:</strong> After chatting about this more with <a href="http://palez.github.io/">Paley</a>, I think we've managed to nail down the pros and cons of the actor model + reference capabilities system, in addition to the technical benefits mentioned above.</p>
<h3>PROS</h3>
<ul>
<li><strong>Explicitness.</strong> With reference capabilities, you must write down exactly what you are doing and what you will be doing with each variable.</li>
<li><strong>Readability.</strong> This goes hand in hand with explicitness, because capabilities are essentially written intentions. When you come back months later to read the code, hopefully it'll be easier to understand what you were thinking at the time.</li>
<li><strong>Programming with concurrency in mind.</strong> This model makes you constantly aware that the code is meant to be executed concurrently. Although that is a lot to keep in your head at once, it forces you to always be thinking about resource and memory management.</li>
</ul>
<h3>CONS</h3>
<ul>
<li><strong>Coupling between the "concurrency" stuff and the "regular" stuff.</strong> In the traditional multi-threaded paradigm, the concurrency and parallelization bits are somewhat localized to the thread management code, but we lose this separation of concerns here.</li>
<li><strong>Fighting with the compiler.</strong> This is inevitable and it can take a time before the error messages are more useful than annoying. Pony (or any language with a complicated type system) does not enable fast prototyping. But maybe changing capabilities to satisfy the compiler is not so different from putting * and &#x26; everywhere until g++ is happy?</li>
<li><strong>Unreadability.</strong>  Yes, I know I put this as a pro too. Capabilities clutter up the code when you're just trying to get a sense of what the program is doing and don't care about the nitty-gritty details.</li>
</ul>
</div></div></article></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Worry-free Concurrent Programming in Pony","date":"2017-05-30T00:00:00.322Z","tags":["pony","programming languages"],"slug":"pony","content":"\u003cp\u003eI spent the past week at the \u003ca href=\"https://pliss2017.github.io/\"\u003eProgramming Language Implementation Summer School\u003c/a\u003e in Bertinoro, Italy. Throughout my undergrad I've avoided taking classes in the summer but when Ron told me about this one in Italy I couldn't not apply. Now that the week is over and I'm sunning it up in Croatia, I want to write a few blog posts about some stuff I learned both in and out of the classroom. This is the first of three posts.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/blog/pony/pliss-classroom.jpeg\" alt=\"PLISS classroom\" title=\"PLISS classroom\"\u003e\u003c/p\u003e\n\u003cp\u003eWriting concurrent programs is hard. At the heart of the challenge is handling shared data — and to that, our Intro to Computer Science professors say: put a lock on it! But programming with locks and semaphores is very difficult to get right and is torturously slow (imagine Facebook locking each of Donald Trump’s posts when someone comments). The \u003ca href=\"https://www.ponylang.org/\"\u003ePony\u003c/a\u003e language, being developed at \u003ca href=\"https://wp.doc.ic.ac.uk/sd/\"\u003eSophia Drossopoulou\u003c/a\u003e’s group at Imperial College London, introduces two core ideas such that, if you can get your program to compile, guarantees memory safety (among other things).\u003c/p\u003e\n\u003ch2\u003eThe Actor Model\u003c/h2\u003e\n\u003cp\u003eThe first of these is the actor model. This isn’t really a new idea — probably the best known language that uses this is Erlang. Instead of the traditional threads, we have actors, and they define the concurrent system. Each actor does its own computation, receives messages, and sends messages to other actors. The actor executes each message in its entirety and sequentially. So the concurrency happens when you have multiple actors, each doing their own thing.\u003c/p\u003e\n\u003cp\u003eTo me this is a very intuitive model to think about parallel work. Suppose I want to ask a bunch of people to do my homework. I’d probably make photocopies to distribute to each of my minions, and they’ll each work on an assigned question, and send it back to me when they’re done. Notice that while they’re doing the work, each one has its own copy — there is no passing around one homework a la Sisterhood of the Traveling Pants. In the actor model, each actor always has its own private state.\u003c/p\u003e\n\u003ch2\u003eReference Capabilities\u003c/h2\u003e\n\u003cp\u003eBut this is not still not enough, because we need to define the rules around shared data. Pony’s solution to this is reference capabilities: an extra tag that you write with the type (Pony is strongly typed) for each variable that tells you how that variable can be used. There are \u003ca href=\"https://tutorial.ponylang.org/capabilities/reference-capabilities.html\"\u003e6 of these\u003c/a\u003e, from \u003cem\u003eiso\u003c/em\u003e and \u003cem\u003eval\u003c/em\u003e (isolated, as in no other variables can access the data, and immutable, respectively) to \u003cem\u003eref\u003c/em\u003e and \u003cem\u003ebox\u003c/em\u003e (mutable and read-only, respectively).\u003c/p\u003e\n\u003cp\u003eConfused? I am. From a theoretical perspective, ref capabilities are absolutely beautiful. But for an engineer who just wanted to hit the ground running, the powerful type system was, at first, a bit off-putting. I’m used to writing programs that compile with little effort (usually because the problems are hiding somewhere where it’s hard to diagnose and hard to debug).\u003c/p\u003e\n\u003ch2\u003eTada...\u003c/h2\u003e\n\u003cp\u003eThis combination gets us some very nice (and interesting) guarantees.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eNo data races.\u003c/strong\u003e If an actor sees some object as writeable (\u003cem\u003eiso\u003c/em\u003e or \u003cem\u003eref\u003c/em\u003e) then all other actors see the object as unreadable and unwritable (\u003cem\u003etag\u003c/em\u003e).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eImmutability is deep and permanent.\u003c/strong\u003e If an actor sees some object as immutable (\u003cem\u003eval\u003c/em\u003e), its contents are also immutable.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAtomicity.\u003c/strong\u003e We can trace what happened when without too much difficulty. If an actor \u003ci\u003ea\u003c/i\u003e at some point \u003ci\u003eC\u003c/i\u003e sees an object \u003ci\u003eo\u003c/i\u003e with a non-tag capability(so \u003ci\u003ea\u003c/i\u003e can actually do something with \u003ci\u003eo\u003c/i\u003e) without message receipts, and \u003ci\u003eo\u003c/i\u003e is different at some earlier point, then \u003ci\u003ea\u003c/i\u003e did it: \u003ci\u003ea\u003c/i\u003e must have either created or modified \u003ci\u003eo\u003c/i\u003e.\u003c/li\u003e\n\u003cli\u003eLots more \u003ca href=\"https://tutorial.ponylang.org/capabilities/guarantees.html\"\u003ehere\u003c/a\u003e...\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eWhat about Rust? Why not Rust?\u003c/h2\u003e\n\u003cp\u003eIdiomatically I think Rust's and Pony's approaches to memory safety aren't so different -- capabilities can capture a bit more information than mutabilities, but essentially they are just about annotating data with restrictions. However, Pony’s core focus is safe concurrency, and with the actor model you have to think in a totally different way even when you’re writing a sequential program (though who ever did anything interesting with a sequential program?), whereas Rust is more familiar for those of us coming from the C world.\u003c/p\u003e\n\u003cp\u003eOne advantage that Pony has over Rust is creating and manipulating cyclic data structures. Cyclic data structures are nontrivial in Rust, partly because of the mutability qualifiers (I mean check out this implementation of \u003ca href=\"https://github.com/nrc/r4cppp/tree/master/graphs\"\u003egraphs\u003c/a\u003e). According to Sophia, it’s much more painless in Pony (need to try this for myself though).\u003c/p\u003e\n\u003ch2\u003eBorrowing?\u003c/h2\u003e\n\u003cp\u003eThere isn’t really a concept of borrowing yet, although I think you can fake it by \u003ca href=\"https://tutorial.ponylang.org/capabilities/recovering-capabilities.html\"\u003erecovering capabilities\u003c/a\u003e (essentially change the capability so the variable can be passed to and changed by another actor). It’s next on their to-do list, though!\u003c/p\u003e\n\u003ch2\u003eHow usable is it, really?\u003c/h2\u003e\n\u003cp\u003eI think there’s a trend in recent years towards languages that have as flat a learning curve as possible. It seems like languages that are a bit prickly at first (because of the type system or otherwise) haven’t gained much traction. On the other hand, dynamic languages like Python and Ruby are still going strong. Rust, for example, started off with a lot more structure baked into the language and spent years simplifying and pushing abstractions into libraries (see \u003ca href=\"https://doc.rust-lang.org/std/cell/\"\u003eCells\u003c/a\u003e and \u003ca href=\"https://doc.rust-lang.org/std/cell/struct.RefCell.html\"\u003eRefCells\u003c/a\u003e for example) to make it more accessible. The Pony developers don't currently anticipate having to water down their type system (I asked :-) ).\u003c/p\u003e\n\u003cp\u003eLast week, I was definitely on the Python train… now I’m not so sure. What would it take for the masses to adopt a language like Pony?\u003c/p\u003e\n\u003cp\u003eCan we convince the programming community to have enough patience to handle compiler errors if it means we have fewer of those seriously painful concurrency bugs later down the line?\u003c/p\u003e\n\u003cp\u003eI’d personally much rather debug a compile error with a nice message than a deadlock, but first it's about getting out of the mindset that the compilation step is trivial.\u003c/p\u003e\n\u003cbr /\u003e\n\u003cp\u003e\u003cstrong\u003e06-01-2017 EDIT:\u003c/strong\u003e After chatting about this more with \u003ca href=\"http://palez.github.io/\"\u003ePaley\u003c/a\u003e, I think we've managed to nail down the pros and cons of the actor model + reference capabilities system, in addition to the technical benefits mentioned above.\u003c/p\u003e\n\u003ch3\u003ePROS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eExplicitness.\u003c/strong\u003e With reference capabilities, you must write down exactly what you are doing and what you will be doing with each variable.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eReadability.\u003c/strong\u003e This goes hand in hand with explicitness, because capabilities are essentially written intentions. When you come back months later to read the code, hopefully it'll be easier to understand what you were thinking at the time.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eProgramming with concurrency in mind.\u003c/strong\u003e This model makes you constantly aware that the code is meant to be executed concurrently. Although that is a lot to keep in your head at once, it forces you to always be thinking about resource and memory management.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eCONS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCoupling between the \"concurrency\" stuff and the \"regular\" stuff.\u003c/strong\u003e In the traditional multi-threaded paradigm, the concurrency and parallelization bits are somewhat localized to the thread management code, but we lose this separation of concerns here.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eFighting with the compiler.\u003c/strong\u003e This is inevitable and it can take a time before the error messages are more useful than annoying. Pony (or any language with a complicated type system) does not enable fast prototyping. But maybe changing capabilities to satisfy the compiler is not so different from putting * and \u0026#x26; everywhere until g++ is happy?\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eUnreadability.\u003c/strong\u003e  Yes, I know I put this as a pro too. Capabilities clutter up the code when you're just trying to get a sense of what the program is doing and don't care about the nitty-gritty details.\u003c/li\u003e\n\u003c/ul\u003e\n"}},"__N_SSG":true},"page":"/writing/[slug]","query":{"slug":"pony"},"buildId":"pMomVlEDc5orNd4LjOJ5J","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>