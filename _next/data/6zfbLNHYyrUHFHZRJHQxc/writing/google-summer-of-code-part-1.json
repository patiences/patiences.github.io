{"pageProps":{"post":{"title":"Google Summer of Code, Part 1","date":"2018-06-19T00:30:00.322Z","slug":"google-summer-of-code-part-1","content":"<p>I’m about a month into my <a href=\"https://summerofcode.withgoogle.com/\">Google Summer of Code</a> project with <a href=\"https://pybee.org/\">BeeWare</a>, and it’s high time I wrote about the specific library I'm working on and what I’ve been up to.</p>\n<h2>About VOC</h2>\n<p><a href=\"https://pybee.org/project/projects/bridges/voc/\">VOC</a> is a library that compiles Python code into Java bytecode.\nIt fits into BeeWare’s overarching goal of enabling mobile development in Python because it allows you to run your Python source code on the JVM, and write Python code that interacts with native Android APIs. Essentially, Python source files are parsed into abstract syntax trees and converted into JVM bytecode instructions. Python types and the standard library are implemented in Java (though no Java file is ever created).\nThe result is a bunch of Java class files that can be executed in the JVM.</p>\n<h2>My Project</h2>\n<p>My project goal is to significantly improve the runtime of VOC-generated bytecode. VOC is a fairly naive compiler,\nand no significant efforts have been made (until now!) to optimize performance, which is good for me because there\nare some pretty low-cost things we can do for a major boost.\nFind my initial project proposal<a href=\"https://github.com/pybee/voc/issues/772%22\">here</a> (though it became outdated about a week into the work).</p>\n<h2>Object Creation is Expensive</h2>\n<p>Everything in Python is an Object. This means that even small programs can create tons of Objects, including integers, booleans, and strings. Creating an integer, for example, looks like this in bytecode:</p>\n<pre><code>NEW org/python/types/Int\nDUP\nLDC2_W (Long 42)\nINVOKESPECIAL org/python/types/Int.init (J)V\n</code></pre>\n<p>Luckily we can exploit the fact that integers and booleans are immutable objects. Strings are immutable as well, but\nit’s hard to tell which strings are used often enough that they should be cached. Integers, on the other hand, especially\nsmall integers, are used all the time. This optimization idea comes from\n<a href=\"https://github.com/python/cpython/blob/master/Objects/longobject.c#L43\">CPython</a>, where integers -5 to 256\ninclusive are pre-allocated, shared and created only once. That’s exactly what we did in VOC, by making the Int constructor\nprivate and checking if we can use a pre-allocated Int before calling the constructor.</p>\n<p>So on the bytecode side, we can replace a constructor call with a static method call which is much cheaper:</p>\n<pre><code>LDC 42\nINVOKESTATIC org/python/types/Int.getInt (J)Lorg/python/types/Int;\n</code></pre>\n<p>On a <a href=\"https://github.com/pybee/voc/blob/master/tests/bench_datatypes.py\">benchmarking test</a>, this results\nin about a 15% performance improvement. While this number is synthetic in the sense that the test is written to exploit\nthis and only this optimization, it is still a verification of performance improvement.</p>\n<p>For booleans, since there are only two objects, the savings are even better:</p>\n<pre><code>// Without optimization\nNEW org/python/types/Bool\nDUP\nICONST_0\nINVOKESPECIAL org/python/types/Bool.init (Z)V\n\n// With optimization\nGETSTATIC org/python/types/Bool.FALSE (Lorg/python/types/Bool;)\n</code></pre>\n<p>Amazingly, on the benchmark this shows about a 50% improvement.</p>\n<h2>Reflections</h2>\n<p>So far I am really enjoying my GSoC project. My mentor <a href=\"https://github.com/freakboy3742\">Russ</a> is super knowledgeable\nand is great at giving me just enough guidance that I get unstuck, but not telling me I have to implement something a specific way\n-- anything goes as long as I can justify it or show a performance improvemnt. That freedom is empowering and refreshing, as\nI’m used to adhering to very specific acceptance criteria and usually pre-defined implementation strategies.</p>\n<p>Surprisingly, it’s a great complement to my engineering experience and has forced me to work on a few skills that I’ve\nnever had much reason to hone before, like:</p>\n<ul>\n<li>\n<p>Learning a new codebase without much “meta” information. VOC is a pretty new project and there’s not a lot of documentation about the code, architecture or design documents, etc. I’ve learned that answers always come from reading the code.</p>\n</li>\n<li>\n<p>Consistently making progress without humans around. Usually, on a team of engineers in the same office or at least the same time zone, I’d work at a problem for a few hours or a day maximum before asking for help or someone to talk things out with. But I don’t want to pester Russ (who is in a different time zone) too much, and I never expect a real-time response to a question. Learning how to debug the codebase to move forward is truly the most important skill when onboarding.</p>\n</li>\n<li>\n<p>Old school debugging! Debugging without good tools is a pain. There’s no white-box testing on VOC (yet?), so I’m relying on good ol' print statements (I haven't found tools that equally accommodate Python, Java and Java bytecode). Of the three, Java bytecode is definitely the most ornery, and tinkering with bytecode is a big part of this project.</p>\n</li>\n</ul>\n<p>You can follow the discussion and progression around this work <a href=\"https://github.com/pybee/voc/pull/825\">here</a>, <a href=\"https://github.com/pybee/voc/pull/830\">here</a>, and <a href=\"https://github.com/pybee/voc/pull/824\">here</a>. My github incompetence is woefully obvious here, but I am leaving those giant commit chains there in hope of having lots of improvement to show by the end of the summer.</p>\n"}},"__N_SSG":true}